{"ast":null,"code":"function capitalizeFirstLetter(str){if(!str){return\"\";}return str.charAt(0).toUpperCase()+str.slice(1);}const validChords=[\"A\",\"B\",\"C\",\"D\",\"Dm\",\"E\",\"Em\",\"F\",\"Fm\",\"G\"];function checkInputsAreValid(chordShape,capoPosition){if(!validChords.includes(chordShape)){return\"Error! invalid chord shape given.\";}else if(!Number.isInteger(capoPosition)){return\"Error! invalid capo position given (not an integer).\";}else if(!(-1<capoPosition)||!(capoPosition<13)){return\"Error! invalid capo position given (not within valid range).\";}else{return\"\";}}export function capoLogic(chordShape,capoPosition){// If minor chord, calculate for capo-ing same as for a major chord, but add 'minor'.\n// TODO: Certainly there's a better way to do this.\n// Handle if checking a chord near the end of the array\nconst duplicatedValidChords=[...validChords,...validChords];// Capitalize first letter of chord shape:\nchordShape=capitalizeFirstLetter(chordShape);// Check that inputs are valid:\nconst errorChecking=checkInputsAreValid(chordShape,capoPosition);if(errorChecking!==\"\"){return errorChecking;}let isMinor=false;if(chordShape.charAt(1)==\"m\"){isMinor=true;}const chordSansMinor=chordShape.charAt(0);const chords=[\"A\",\"A#\",\"B\",\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\"];// Get index of chordSansMinor within chords.\n// Add the capo # to that, and get the value of chords at that index.\nconst originalIndex=chords.indexOf(chordSansMinor);let calculatedChord=chords[originalIndex+capoPosition];if(isMinor){calculatedChord+=\"m\";}let newResultString=\"\";if(calculatedChord!==\"\"){newResultString=\"This shape will actually produce the sound of chord \"+calculatedChord;}return newResultString;}export function removeCapoLogic(chordShape,capoPosition){// If minor chord, calculate for capo-ing same as for a major chord, but add 'minor'.\n// TODO: Certainly there's a better way to do this.\n// Handle if checking a chord near the end of the array\nconst duplicatedValidChords=[...validChords,...validChords];// Capitalize first letter of chord shape:\nchordShape=capitalizeFirstLetter(chordShape);// Check that inputs are valid:\nconst errorChecking=checkInputsAreValid(chordShape,capoPosition);if(errorChecking!==\"\"){return errorChecking;}let isMinor=false;if(chordShape.charAt(1)==\"m\"){isMinor=true;}const chordSansMinor=chordShape.charAt(0);const chords=[\"A\",\"A#\",\"B\",\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\"];// Get index of chordSansMinor within chords.\n// Add the capo # to that, and get the value of chords at that index.\nconst originalIndex=chords.indexOf(chordSansMinor);let calculatedChord=chords[originalIndex-capoPosition];if(isMinor){calculatedChord+=\"m\";}let newResultString=\"\";if(calculatedChord!==\"\"){newResultString=\"Taking off the capo will make this a \"+calculatedChord;}return newResultString;}","map":{"version":3,"names":["capitalizeFirstLetter","str","charAt","toUpperCase","slice","validChords","checkInputsAreValid","chordShape","capoPosition","includes","Number","isInteger","capoLogic","duplicatedValidChords","errorChecking","isMinor","chordSansMinor","chords","originalIndex","indexOf","calculatedChord","newResultString","removeCapoLogic"],"sources":["/Users/kathryne/transpose-keys/src/translate-capo-logic.ts"],"sourcesContent":["function capitalizeFirstLetter(str: string): string {\n  if (!str) {\n    return \"\";\n  }\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nconst validChords: string[] = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"Dm\",\n  \"E\",\n  \"Em\",\n  \"F\",\n  \"Fm\",\n  \"G\",\n];\n\nfunction checkInputsAreValid(chordShape: string, capoPosition: number): string {\n  if (!validChords.includes(chordShape)) {\n    return \"Error! invalid chord shape given.\";\n  } else if (!Number.isInteger(capoPosition)) {\n    return \"Error! invalid capo position given (not an integer).\";\n  } else if (!(-1 < capoPosition) || !(capoPosition < 13)) {\n    return \"Error! invalid capo position given (not within valid range).\";\n  } else {\n    return \"\";\n  }\n}\n\nexport function capoLogic(chordShape: string, capoPosition: number): string {\n  // If minor chord, calculate for capo-ing same as for a major chord, but add 'minor'.\n\n  // TODO: Certainly there's a better way to do this.\n  // Handle if checking a chord near the end of the array\n  const duplicatedValidChords: string[] = [...validChords, ...validChords];\n\n  // Capitalize first letter of chord shape:\n  chordShape = capitalizeFirstLetter(chordShape);\n\n  // Check that inputs are valid:\n  const errorChecking = checkInputsAreValid(chordShape, capoPosition);\n  if (errorChecking !== \"\") {\n    return errorChecking;\n  }\n\n  let isMinor = false;\n  if (chordShape.charAt(1) == \"m\") {\n    isMinor = true;\n  }\n\n  const chordSansMinor = chordShape.charAt(0);\n\n  const chords = [\n    \"A\",\n    \"A#\",\n    \"B\",\n    \"C\",\n    \"C#\",\n    \"D\",\n    \"D#\",\n    \"E\",\n    \"F\",\n    \"F#\",\n    \"G\",\n    \"G#\",\n  ];\n\n  // Get index of chordSansMinor within chords.\n  // Add the capo # to that, and get the value of chords at that index.\n\n  const originalIndex = chords.indexOf(chordSansMinor);\n\n  let calculatedChord = chords[originalIndex + capoPosition];\n\n  if (isMinor) {\n    calculatedChord += \"m\";\n  }\n\n  let newResultString: string = \"\";\n  if (calculatedChord !== \"\") {\n    newResultString =\n      \"This shape will actually produce the sound of chord \" + calculatedChord;\n  }\n  return newResultString;\n}\n\nexport function removeCapoLogic(\n  chordShape: string,\n  capoPosition: number\n): string {\n  // If minor chord, calculate for capo-ing same as for a major chord, but add 'minor'.\n\n  // TODO: Certainly there's a better way to do this.\n  // Handle if checking a chord near the end of the array\n  const duplicatedValidChords: string[] = [...validChords, ...validChords];\n\n  // Capitalize first letter of chord shape:\n  chordShape = capitalizeFirstLetter(chordShape);\n\n  // Check that inputs are valid:\n  const errorChecking = checkInputsAreValid(chordShape, capoPosition);\n  if (errorChecking !== \"\") {\n    return errorChecking;\n  }\n\n  let isMinor = false;\n  if (chordShape.charAt(1) == \"m\") {\n    isMinor = true;\n  }\n\n  const chordSansMinor = chordShape.charAt(0);\n\n  const chords = [\n    \"A\",\n    \"A#\",\n    \"B\",\n    \"C\",\n    \"C#\",\n    \"D\",\n    \"D#\",\n    \"E\",\n    \"F\",\n    \"F#\",\n    \"G\",\n    \"G#\",\n  ];\n\n  // Get index of chordSansMinor within chords.\n  // Add the capo # to that, and get the value of chords at that index.\n\n  const originalIndex = chords.indexOf(chordSansMinor);\n\n  let calculatedChord = chords[originalIndex - capoPosition];\n\n  if (isMinor) {\n    calculatedChord += \"m\";\n  }\n\n  let newResultString: string = \"\";\n  if (calculatedChord !== \"\") {\n    newResultString = \"Taking off the capo will make this a \" + calculatedChord;\n  }\n  return newResultString;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}